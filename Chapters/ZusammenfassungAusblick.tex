\section{Zusammenfassung und Ausblick}

Im Rahmen dieser Arbeit wurde eine bereits existierende Software zum Vergleich von beliebig vielen textbasierten Dateien überarbeitet und erweitert. Besonders im Fokus standen die Aspekte der Genauigkeit von Algorithmen, der Laufzeit, sowie der Benutzbarkeit und Verständlichkeit der Anwendung. Dafür wurde zunächst das Zeilenmatching in der bestehenden Funktionsweise untersucht, wobei nennenswerte funktionale und zeitliche Verbesserungen bspw. durch das neue \emph{Best Match}-Verfahren eingeführt werden konnten. Ähnliches galt auch für den zeilenweisen Textvergleich, dessen Funktionsweise durch die Integration der Matching-Komponente hinsichtlich der Genauigkeit verbessert wurden. Zusätzlich profitiert der Vergleichsmodus nun von den zuvor genannten Verbesserungen des Zeilenmatchings. 

Ein weiterer großer Teil der Arbeit bestand daraus, zwei neue Vergleichsalgorithmen für XML und JSON zu konzipieren und zu implementieren. Diese arbeiten primär auf einer strukturellen Basis mit Hilfe von Dokumentbäumen und sind in der Lage Markup zu ignorieren und daher strikt inhaltlich zu vergleichen. Da die Algorithmen Elemente größtenteils anhand von eindeutigen Identifiern matchen und vergleichen, sind sowohl semantisch genauere als auch insgesamt schnellere Vergleiche möglich. Letzteres entsteht dadurch, dass ganze Teilbäume vom Vergleich ausgeschlossen werden können, wenn der zugehörige Identifier nur in einer Datei existiert. Zusätzlich eliminieren die Algorithmen durch dieses Vorgehen die Möglichkeit von zufälligen, falschen Bewertungen.

In Hinblick auf die Laufzeit wurde ein Verfahren entwickelt, womit die Anwendung verfügbare Hardware effektiv nutzt. Vergleiche werden nun gleichmäßig auf verfügbare CPU-Threads verteilt, wodurch für jeden Vergleichsmodus je nach Hardwarekonfiguration proportionale Verbesserungen messbar sind. Sowohl die Laufzeitverbesserungen als auch die Funktionsweise der strukturbasierten Algorithmen wurden zudem in Kapitel \ref{test} anhand von Beispieldateien präsentiert.

Auch das User Interface erhielt zahlreiche Änderungen, die sowohl kosmetisch als auch funktional sind. Neben einer Änderung des Java-spezifischen \emph{Look-and-Feels}, welches nun abhängig vom unterliegenden Betriebssystem ist, wurden weitere Funktionen erstellt um die Benutzung der Software für den Benutzer angenehmer zu machen. Die Auswahl von Dateien für eine graphische Anzeige der Unterschiede gibt dem Benutzer nun durch das Ausgrauen der Matrix zusätzliche visuelle Informationen dazu, welche Vergleiche sinnvoll auszuwerten wären. Zudem können Vergleiche nun persistent gespeichert werden, die Funktionsweise kann durch mehr Parameter für den vorliegenden Anwendungsfall angepasst werden und Aktionen und Fehler werden nun automatisch über ein eigenes Log-System festgehalten.

Insgesamt lässt sich sagen, dass die Anwendung MultiTextCompare sich nun nicht mehr nur durch die Anzahl der zu vergleichenden Dateien von bestehender Software abhebt, sondern zusätzlich Möglichkeiten bietet um Dateien vom Typ JSON und XML spezialisiert inhaltlich zu vergleichen. 

Trotzdem gibt es noch Aspekte, die verbessert werden können. Dazu zählt z.B. eine weitere Anpassung im Matching, die nicht mehr bloß zeilenbasiert nach Matches sucht, sondern tatsächlich versucht verschobene Textblöcke zu erstellen. Desweiteren könnte die Matching-Komponente auch auf XML und JSON angepasst werden, sodass diese auch Markup erkennt und diesen beim Feststellen von Matches besonders beachtet. Dies ist auch etwas was in Abb. \ref{fig:bestMatchResult} zu sehen war, wo Markup-Elemente gleichermaßen zur Ähnlichkeit von Zeilen beigetragen haben wie der eigentliche Inhalt der Dateien. Das Best-Match Verfahren bringt zwar bessere Ergebnisse als wenn nach dem erstem Match die Suche abgebrochen wird, aber die Darstellung könnte durch eine Spezialisierung auf bestimmte Dateiformate weiter verbessert werden. Als letzten Punkt ließe sich noch die Einbindung des Dateiformats YAML nennen. Dies ist besonders im in der Einleitung genannten Cloud-Umfeld als Konfigurationsformat weit verbreitet und ist auch durch die Jackson Bibliothek unterstützt. Da JSON eine direkte Untermenge von YAML ist \cite{yamlSpec}, sollte auch der strukturelle Vergleichsalgorithmus nicht neu entwickelt, sondern bloß angepasst werden müssen.